/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var _ = require('underscore');
var dox = require('dox');
var path = require('path');

var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-doc');

var pathTo3akaiuxAPI = null;
var cachedDocs = {
    'backend': {},
    'frontend': {}
};

/**
 * Retrieves the docs for the requested module
 * 
 * @param  {String}     moduleId        The module to get docs for
 * @param  {String}     type            The type of the module to get docs for, this can be 'frontend' or 'backend'
 * @param  {Function}   callback        The function to call when complete
 * @param  {Object}     callback.doc    The documentation for the module requested
 */
var getDoc = module.exports.getDoc = function(moduleId, type, callback) {
    var validator = new Validator();
    validator.check(moduleId, {'code': 400, 'msg': 'Missing name'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'Missing type'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'The type is not valid'}).isIn(['backend','frontend']); 

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    if (cachedDocs[type] && cachedDocs[type][moduleId]) {
        return callback(null, cachedDocs[type][moduleId]);
    } else {
        return callback({'code': 404, 'msg': 'No documentation for this module was found'});
    }
};

/**
 * Parse module doc into json using dox
 *
 * @param   {string}      err           Error message
 * @param   {String[]}    doc           Array of documentation for all modules
 * @param   {String}      moduleId      The module to get docs for
 * @param   {String}      data          Data that was returned after reading the file completed
 */
var parseJSDoc = function(err, doc, moduleId, data) {
    if (!err) {
        try {
            doc[moduleId] = dox.parseComments(data);
        } catch (err) {
            log().warn({
                err: err,
                data: data
            }, 'Failed parsing comment data with dox for file %s', moduleId);
        }
    } else {
        log().error('Failed reading' + moduleId);
    }
};

/**
 * Parse the backend modules that are available in the node_modules folder
 *
 * @param   {string}      moduleId        The module to get docs for
 * @param   {Function}    callback        The function to call when complete
 * @param   {Object}      callback.doc    The documentation for the module requested
 * @api private
 */
var readBackendDoc = function(moduleId, callback) {

    var dir = 'node_modules/' + moduleId + '/lib';

    /*!
     * Filters out all non-javascript files and folders, as we don't want to generate documentation for these,
     * and returns the filtered array.
     *
     * @param  {String[]}   libs       The unfiltered Array of file names in the module lib directory
     * @return {String[]}              The returned, filtered, Array of file names that can be used to generate documentation for
     */
    var filterLibs = function(libs) {
        var allowedLibs = [];
        for (var i = 0; i < libs.length; i++) {
            if (libs[i].indexOf('.js') !== -1) {
                allowedLibs.push(libs[i]);
            }
        }
        return allowedLibs;
    };

    IO.getFileListForFolder(dir, function(err, libs) {
        if (err) {
            log().warn({'err': err, 'dir': dir}, 'Failed getting file list to parse dox documentation.');
            return callback({'code': 404, 'msg': 'No documentation for this module was found'});
        }

        // Filter out all non-javascript files
        libs = filterLibs(libs);

        var toDo = libs.length;
        var done = 0;
        var doc = {};

        for (var i=0; i < libs.length; i++) {
            var lib = libs[i];

            (function(lib) {
                IO.readFile(dir + '/' + lib, function(err, data) {
                    done++;

                    parseJSDoc(err, doc, lib, data);

                    if (done === toDo) {
                        return callback(err, doc);
                    }
                });
            })(lib);
        }

        if (!libs.length) {
            callback({'code': 404, 'msg': 'No documentation for this module was found'});
        }
    });
};

/**
 * Parse the frontend modules that are available in the 3akaiuxAPI folder starting with oae.api.
 *
 * @param   {string}      moduleId          The frontend module to get docs for
 * @param   {Function}    callback          The function to call when complete
 * @param   {Object}      callback.doc      The documentation for the module requested
 * @api private
 */
var readFrontendDoc = function(moduleId, callback) {
    var doc = {};
    IO.readFile(pathTo3akaiuxAPI + '/oae.api.' + moduleId + '.js', function(err, data) {
        parseJSDoc(err, doc, moduleId, data);
        return callback(err, doc);
    });
};

/**
 * Initializes the documentation by fetching all modules + configuration for those modules and caching it
 * 
 * @param   {String}     uiPath                The path to the 3akaiux folder
 * @param   {Function}   callback              The function to call when complete
 */
var initializeDocumentation = module.exports.initializeDocumentation = function(uiPath, callback) {
    var modules = Modules.getAvailableModules();
    var toDo = modules.length;
    var done = 0;

    pathTo3akaiuxAPI = uiPath + '/shared/oae/api';

    for (var i = 0; i < toDo; i++) {
        var module = modules[i];
        (function(module) {
            readBackendDoc(module, function(err, doc) {
                done++;
                cachedDocs.backend[module] = doc;
                if (done === toDo) {
                    loadAvailableFrontendModules(callback);
                }
            });
        })(module);
    }
};

/**
 * Function that puts all the frontend modules in an array
 * 
 * @param   {Function}   callback     The function to call when complete
 */
var loadAvailableFrontendModules = function(callback) {
    var _modules = [];
    IO.getFileListForFolder(pathTo3akaiuxAPI, function(err, modules) {
        if (err) {
            log().error(err);
        } else {
            var toDo = modules.length;
            for (var i = 0; i < toDo; i++) {
                var extension = path.extname(modules[i]);
                var basename = path.basename(modules[i], extension);
                if (basename.substring(0, 7) === 'oae.api' && extension.toLowerCase() === '.js' && modules[i] !== 'oae.api.js') {
                    _modules.push(basename.substr(8));
                }
            }
            initializeFrontendModules(_modules, callback);
        }
    });
};

/**
 * Function that loads the frontend documentation into the cacheDocs
 * 
 * @param  {Array}      modules         Array with all the frontend module names
 * @param  {Function}   callback        The function to call when complete
 */
var initializeFrontendModules = function(modules, callback) {
    var toDo = modules.length;
    var done = 0;

    _.each(modules, function(moduleId) {
        (function(moduleId) {
            readFrontendDoc(moduleId, function(err, doc) {
                done++;
                cachedDocs.frontend[moduleId] = doc;
                if (done === toDo) {
                    callback();
                }
            });
        })(moduleId);
    });

    if (!toDo) {
        callback();
    }
};

/**
 * Returns the available modules from cache depending on the type
 *
 * @param   {String}    type    The module type to get the modules of that type
 *
 * @return  {Object}    Returns an error object with code and message
 * @return  {String[]}  Returns an Array of strings representing the names of the available modules
 */
var getDocumentationNames = module.exports.getDocumentationNames = function(type) {
    if (!cachedDocs[type]) {
        return {'code': 500, 'msg': 'No available module documentation for this type'};
    }

    return _.keys(cachedDocs[type]);
};
